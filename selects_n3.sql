-- ПРЕДСТАВЛЕНИЯ
-- 1.	Создать представление, отображающее всех водителей

CREATE OR REPLACE VIEW AUTO_PERSONNEL_VIEW AS SELECT FIRST_NAME, LAST_NAME, PATHER_NAME FROM AUTO_PERSONNEL;

SELECT * FROM AUTO_PERSONNEL_VIEW;

-- 2.	Создать представление, отображающее все маршруты и количество автомобилей находящихся на каждом маршруте

CREATE OR REPLACE VIEW ROUTES_WITH_COUNT_AUTO AS SELECT ROUTES.NAME AS NAME,
                                                   (SELECT COUNT(*) FROM JOURNAL WHERE ROUTE_ID = ROUTES.ID AND
                                                    TIME_IN IS NULL) AS COUNT FROM ROUTES;

SELECT * FROM ROUTES_WITH_COUNT_AUTO;

-- ХРАНИМЫЕ ПРОЦЕДУРЫ
-- Без параметров
-- 3.	Создать хранимую процедуру, выводящую все маршруты и среднее время проезда по ним в минутах

CREATE OR REPLACE PROCEDURE SHOW_ROUTES_AND_AVG IS
BEGIN
  FOR ROWS IN (SELECT R.NAME, AVG((cast(J.TIME_IN as date) - cast(J.TIME_OUT as date)) * 24 * 60) as AVG_TIME
    FROM JOURNAL J INNER JOIN ROUTES R ON J.ROUTE_ID = R.ID
    WHERE J.TIME_IN IS NOT NULL GROUP BY R.NAME)
    LOOP
      DBMS_OUTPUT.PUT_LINE(ROWS.NAME || ' ' || ROWS.AVG_TIME);
  END LOOP;
END SHOW_ROUTES_AND_AVG;

BEGIN
  SHOW_ROUTES_AND_AVG();
END;

SELECT R.NAME, AVG((cast(J.TIME_IN as date) - cast(J.TIME_OUT as date)) * 24 * 60) as AVG_TIME
FROM JOURNAL J INNER JOIN ROUTES R ON J.ROUTE_ID = R.ID
WHERE J.TIME_IN IS NOT NULL GROUP BY R.NAME;

-- С входными параметрами
-- 4.	Создать хранимую процедуру, имеющую два параметра автомобиль1 и автомобиль2. Она должна возвращать маршруты,
--  по которым автомобиль1 проехал быстрее автомобиля2. Если на каком-либо маршруте один из автомобилей не проезжал,
--  такой маршрут не рассматривается.

-- CREATE OR REPLACE PROCEDURE

CREATE OR REPLACE PROCEDURE BEST_CAR(CAR1 NUMBER, CAR2 NUMBER) IS
BEGIN
  FOR ROWS IN (SELECT DISTINCT NAME FROM JOURNAL J JOIN ROUTES R ON J.ROUTE_ID = R.ID
    WHERE J.AUTO_ID = CAR1 AND (cast(J.TIME_IN as date) - cast(J.TIME_OUT as date)) * 24 * 60 <
    (SELECT MIN((cast(JJ.TIME_IN as date) - cast(JJ.TIME_OUT as date)) * 24 * 60) FROM JOURNAL JJ
    WHERE JJ.AUTO_ID = CAR2 AND JJ.ROUTE_ID =J.ROUTE_ID))
    LOOP
    DBMS_OUTPUT.PUT_LINE(ROWS.NAME);
  END LOOP;
END;

BEGIN
  BEST_CAR(8, 9);
END;

SELECT * FROM JOURNAL J JOIN ROUTES R ON J.ROUTE_ID = R.ID
WHERE J.AUTO_ID = 8 AND (cast(J.TIME_IN as date) - cast(J.TIME_OUT as date)) * 24 * 60 <
(SELECT MIN((cast(JJ.TIME_IN as date) - cast(JJ.TIME_OUT as date)) * 24 * 60) FROM JOURNAL JJ
WHERE JJ.AUTO_ID = 9 AND JJ.ROUTE_ID =J.ROUTE_ID);

-- C выходными параметрами
-- 5.	Создать хранимую процедуру с входным параметром маршрут и двумя выходными параметрами, возвращающими самое
-- короткое время проезда по заданному маршруту и автомобиль, поставивший рекорд

CREATE OR REPLACE PROCEDURE BEST_TIME_ON_THE_ROAD(ROUTE IN NUMBER, TIME OUT NUMBER, CAR OUT NUMBER) IS
  SS NUMBER;
BEGIN
  SELECT MIN((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) AS BESTTIME
  INTO SS FROM JOURNAL J WHERE ROUTE_ID=ROUTE;
  TIME := SS;
  SELECT J.AUTO_ID AS AUTO
  INTO CAR FROM JOURNAL J WHERE ROUTE_ID=ROUTE AND ((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) = TIME;
END;

SELECT J.AUTO_ID AS AUTO
   FROM JOURNAL J WHERE ROUTE_ID=3 AND ((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) = 8.58333333333333333333333333333333333334;

SELECT MIN((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) AS BESTTIME
   FROM JOURNAL J WHERE ROUTE_ID=3;

DECLARE
  ROAD NUMBER := 3;
  TIME NUMBER;
  CAR NUMBER;
BEGIN
  BEST_TIME_ON_THE_ROAD(ROAD, TIME, CAR);
  DBMS_OUTPUT.PUT_LINE(CAR|| ' ' || TIME);
END;


SELECT MIN((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) AS BESTTIME
FROM JOURNAL J WHERE ROUTE_ID=3;

-- ТРИГГЕР
-- Вставка
-- 1.	Создать триггер, который не позволяет добавить автомобиль с номером, который уже есть в парке

CREATE OR REPLACE TRIGGER AUTO_ON_INSERT_CHECK_NUMBER
BEFORE INSERT ON AUTO
FOR EACH ROW
DECLARE
  NUMBER_CARS NUMBER;
BEGIN
  SELECT COUNT(*) INTO NUMBER_CARS FROM AUTO WHERE NUM=:NEW.NUM;
  IF (NUMBER_CARS > 0) THEN
    raise_application_error(-20000, 'AUTO ALREADY EXIST');
  END IF;
END;

-- 2.	Создать триггер, который не позволяет добавить запись в журнал оператора, в которой дата прибытия не NULL

CREATE OR REPLACE TRIGGER JOURNAL_ON_INSERT_IS_NULL
BEFORE INSERT ON JOURNAL
FOR EACH ROW
BEGIN
  IF (:NEW.TIME_IN IS NOT NULL) THEN
    raise_application_error(-20000, 'TIME IN IS NULL');
  END IF;
END;

-- 3.	Создать триггер, который не позволяет отправить в рейс автомобиль, который еще не вернулся в парк

CREATE OR REPLACE TRIGGER JOURNAL_ON_INSERT_CAR_IS_AVL
BEFORE INSERT ON JOURNAL
FOR EACH ROW
DECLARE
  CARS_IS_AVL NUMBER;
BEGIN
  SELECT COUNT(*) INTO CARS_IS_AVL FROM JOURNAL WHERE TIME_IN IS NULL AND AUTO_ID = :NEW.AUTO_ID;
  IF (CARS_IS_AVL != 0) THEN
    raise_application_error(-20000, 'CAR IS NOT AVAILABLE');
  END IF;
END;

-- Модификация

-- 4.	Создать триггер, не позволяющий изменить номер автомобиля

CREATE OR REPLACE TRIGGER AUTO_ON_UPDATE
BEFORE UPDATE ON AUTO
FOR EACH ROW
BEGIN
  IF (UPDATING('NUM')) THEN
    raise_application_error(-20000, 'CAR NUMBER DOES NOT CHANGE');
  END IF;
END;

UPDATE AUTO SET NUM = 'BRAA' WHERE ID=12;

-- 5.	Создать триггер, который не позволит изменить маршрут, в котором есть незаконченные рейсы

CREATE OR REPLACE TRIGGER ROUTES_ON_UPDATE
BEFORE UPDATE ON ROUTES
FOR EACH ROW
DECLARE
  CAR_ON_ROUTE NUMBER;
BEGIN
  SELECT COUNT(*) INTO CAR_ON_ROUTE FROM JOURNAL WHERE TIME_IN IS NULL AND ROUTE_ID = :OLD.ID;
  IF (CAR_ON_ROUTE > 0) THEN
    raise_application_error(-20000, 'ROUTE HAS NOT RETURNED CARS');
  END IF;
END;

UPDATE ROUTES SET NAME='BRAA' WHERE ID=5;

-- 6.	Создать триггер, который не позволит установить время прибытия журнала оператора меньше, чем время отправки

CREATE OR REPLACE TRIGGER JOURNAL_ON_UPDATE
BEFORE UPDATE ON JOURNAL
FOR EACH ROW
BEGIN
  IF (UPDATING('TIME_IN')) THEN
    IF (:NEW.TIME_IN < :NEW.TIME_OUT) THEN
      raise_application_error(-20000, 'TIME_IN < TIME_OUT');
    END IF;
  END IF;
END;

UPDATE JOURNAL SET TIME_IN = TO_TIMESTAMP('2018-02-16 13:36:47', 'YYYY-MM-DD HH24:MI:SS');

-- Удаление
-- 1.	Создать триггер, который при удалении маршрута в случае наличия на него ссылок откатывает транзакцию

CREATE OR REPLACE TRIGGER ROUTES_ON_DELETE
AFTER DELETE ON ROUTES
DECLARE
  QUANTITY_LINK NUMBER;
BEGIN
  SELECT COUNT(*) INTO QUANTITY_LINK
  FROM JOURNAL J WHERE J.ROUTE_ID = DELETED.ID;
  DBMS_OUTPUT.PUT_LINE(DELETED.ID);
  IF (QUANTITY_LINK > 0) THEN
    ROLLBACK;
  END IF;
END;

  SELECT COUNT(*)
  FROM JOURNAL J WHERE J.ROUTE_ID = 5;
DELETE FROM ROUTES WHERE ID=8;

-- 2.	Создать триггер, который при удалении автомобиля в случае наличия на него ссылок откатывает транзакцию



-- 3.	Создать триггер, который при удалении водителя в случае наличия на него ссылок откатывает транзакцию

CREATE OR REPLACE PROCEDURE BEST_TIME_ON_THE_ROAD(ROUTE IN NUMBER, TIME OUT NUMBER, CAR OUT NUMBER) IS
BEGIN
  SELECT MIN((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) AS BESTTIME
  INTO SS FROM JOURNAL J WHERE ROUTE_ID=ROUTE;
  TIME := SS;
  SELECT J.AUTO_ID AS AUTO
  INTO CAR FROM JOURNAL J WHERE ROUTE_ID=ROUTE AND ((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) = TIME;
END;

-- КУРСОРЫ

create or replace PROCEDURE
DRIVER_CASH(START_DATE IN DATE, END_DATE IN DATE, CASH IN NUMBER) IS
  CURSOR PERSONNELS IS (SELECT * FROM AUTO_PERSONNEL);
  TEMPORARY_BEST_TIME NUMBER;
  TEMPORARY_BEST_CAR NUMBER;
  PRIZE FLOAT;

  BEST_TIME NUMBER;

  FIRST_PERSONNEL NUMBER := 0;
  FIRST_BEST_TIME NUMBER := 0;

  SECOND_PERSONNEL NUMBER := 0;
  SECOND_BEST_TIME NUMBER := 0;

  THIRD_PERSONNEL NUMBER := 0;
  THIRD_BEST_TIME NUMBER := 0;

BEGIN
--   DBMS_OUTPUT.PUT_LINE(START_DATE || ' ' || END_DATE);
  FOR PERSONNEL IN PERSONNELS
  LOOP
    BEST_TIME := 0;
    FOR AUTO_PER IN (SELECT * FROM AUTO A WHERE A.PERSONNEL_ID = PERSONNEL.ID)
    LOOP
      FOR ROUTE IN (SELECT DISTINCT J.ROUTE_ID FROM JOURNAL J)
      LOOP
        SELECT MIN((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) AS BESTTIME
        INTO TEMPORARY_BEST_TIME FROM JOURNAL J
        WHERE J.ROUTE_ID=ROUTE.ROUTE_ID AND J.TIME_OUT > START_DATE AND J.TIME_IN < END_DATE;

        SELECT J.AUTO_ID AS AUTO
        INTO TEMPORARY_BEST_CAR FROM JOURNAL J
        WHERE J.ROUTE_ID=ROUTE.ROUTE_ID
        AND ((CAST(J.TIME_IN AS DATE) - CAST(J.TIME_OUT AS DATE)) * 24 * 60) = TEMPORARY_BEST_TIME;

        IF AUTO_PER.ID = TEMPORARY_BEST_CAR THEN
          BEST_TIME := BEST_TIME + 1;
        END IF;
      END LOOP;
    END LOOP;

    IF FIRST_BEST_TIME < BEST_TIME THEN
      THIRD_BEST_TIME := SECOND_BEST_TIME;
      THIRD_PERSONNEL := SECOND_PERSONNEL;
      SECOND_BEST_TIME := FIRST_BEST_TIME;
      SECOND_PERSONNEL := FIRST_PERSONNEL;
      FIRST_PERSONNEL := PERSONNEL.ID;
      FIRST_BEST_TIME := BEST_TIME;
    ELSE
      IF SECOND_BEST_TIME < BEST_TIME THEN
        THIRD_BEST_TIME := SECOND_BEST_TIME;
        THIRD_PERSONNEL := SECOND_PERSONNEL;
        SECOND_PERSONNEL := PERSONNEL.ID;
        SECOND_BEST_TIME := BEST_TIME;
      ELSE
        IF THIRD_BEST_TIME < BEST_TIME THEN
          THIRD_PERSONNEL := PERSONNEL.ID;
          THIRD_BEST_TIME := BEST_TIME;
        END IF;
      END IF;
    END IF;
  END LOOP;


  PRIZE := CASH / 100 * 50;
  DBMS_OUTPUT.PUT_LINE(FIRST_PERSONNEL || ' ' || PRIZE);
  PRIZE := CASH / 100 * 30;
  DBMS_OUTPUT.PUT_LINE(SECOND_PERSONNEL || ' ' || PRIZE);
  PRIZE := CASH / 100 * 20;
  DBMS_OUTPUT.PUT_LINE(THIRD_PERSONNEL || ' ' || PRIZE);
END;

DECLARE
  START_DATE TIMESTAMP := TO_TIMESTAMP('2018-03-13 10:50:45', 'YYYY-MM-DD HH24:MI:SS');
  END_DATE TIMESTAMP := TO_TIMESTAMP('2018-03-13 18:50:45', 'YYYY-MM-DD HH24:MI:SS');
  CASH NUMBER := 1000;
BEGIN
  DRIVER_CASH(START_DATE, END_DATE, CASH);
END;